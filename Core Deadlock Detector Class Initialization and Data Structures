import java.util.*;
import java.util.concurrent.locks.ReentrantLock;

class DeadlockDetector {
    private final Map<Thread, List<Thread>> waitForGraph = new HashMap<>();
    private final Map<Thread, Integer> deadlockRisk = new HashMap<>();
    private final Timer monitoringTimer = new Timer();
    private final MachineLearningModel mlModel = new MachineLearningModel();

    public DeadlockDetector() {
        monitoringTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                monitorThreads();
            }
        }, 0, 2000);
    }

    public synchronized void requestResource(Thread requester, Thread holder) {
        waitForGraph.computeIfAbsent(requester, k -> new ArrayList<>()).add(holder);
        updateDeadlockRisk(requester);
        if (detectDeadlock() || mlModel.predictDeadlock(deadlockRisk)) {
            System.out.println("[AI ALERT] Potential deadlock detected! Resolving...");
            resolveDeadlock();
        }
    }

    private void updateDeadlockRisk(Thread thread) {
        int riskScore = waitForGraph.getOrDefault(thread, new ArrayList<>()).size();
        deadlockRisk.put(thread, riskScore);
    }
